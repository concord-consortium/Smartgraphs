10/9/10:

authoring interface:

  * tray on the left presents an 'outline form' of the activity
  
  * right side will be a 'design mode' view of the real ActivityView
  
  * prompt author when they add a page, do they want to add a step (same
   problem/same data/slight modification) or a page (new problem, new data, 
   etc)?
  
  * will make heavy use of textual cues that *describe* branch decisions, 
    annotations, datasets, actions taken during step, etc. Every object author
    can manipulate has some kind of explanatory phrase associated with it
  
  * author can always 'step through'. At the end of each step, if there's
    a branch, a classic 'white text on not-quite-completely opaque black' 
    overlay will appear, asking the author to choose 'what happens next':
      
      Student Prediction Graph is Too Short --> (Click to choose)
      Student Prediction Graph is Correct Length ---> (Click to choose)
  
  * outline on left shows step currently being shown
  
  * graphs, tables will show the name of datasets and annotations currently
    shown in the graph/table
  
  * if a table is linked to a graph, selection of one or the other will 
    highlight both

  * author can always take notes
  

graph and table:

  * graphs and tables can be 'linked' or not. Linkage is accomplished by
    making them share a common BaseTable object
    
  * linkage means:
    * sharing 'which dataset is selected'
    * data point selections are also shared
    * the same annotation commands are addressed to and interpreted by both
    * input events in either result in equivalent application-level events
    * graph and table share responder 'state'
  
  * there is the notion of an 'example graph'. Whenever you open a graph 
    (which is now done by *name*), the semantics are you copy the example
    graph to the session. Then the author references a graph in a later page,
    he or she is prompted to specify whether it's the same graph that may have
    been modified previously, or a *new* graph also copied from the same
    example is to be shown.
    
  * All session state is copied to at end of each page so the user can
    revisited/restarted from that point. This means copying graph state too.
    
  * Possibly in the future state could also be copied & frozen at the end 
    of each step -- but this seems likely to involve a lot of overhead & 
    isn't clearly needed


annotations:

  * static annotations are represented as a view
  * animated annotations
  * 'modifier' annotations like de-emphasizing all points in a dataset or
    emphasizing a particular point
    
  * note many annotations are represented 
  
  * annotations can be clicked on
  
  
activity view and view controller:

  * recognize a 'design mode' during authoring, versus a "for real" mode
  
  * in design mode, the submit button shows the next step, or page, or 
    prompts the author to choose which branch is to be pursued (see above)
    even though there isn't real data to evaluate.
    
  * ie, you always 'swim' the app.

7/19/10
-------

design issue: sequencing commands, laying out buttons, referring to next steps, and referring to context variables

(wouldn't some degree of polymorphism be nice here...)

CommandInvocation (could be referenced by a Button or a GuideStep)
  index
  command
  args

LaidOutButton
  step
  layout
  button
  
NO!: NextStepReference
  step
  key     (for reference by a 'gotoStep' action; this allows us to define 'gotoNextHint' or 'gotoDone' *commands*
           that don't require arguments that specify the guid of the next step specifically)
  nextStep
  
  ***NO. Let's try to stick to the principle that the authoring system defines conveniences, and the runtime is simple.
  So don't introduce an unnecessary layer of indirection to the runtime.
  
  
** how should 'args' reference context variables?
  
  
  args looks like { arg1: val1, arg2: val2 }
  
  but ... what about referencing context variables in there. Think
  
  
  storeCurrentlySelectedPoint(dataSeries: '...', contextVar: '...')

  addAnnotation( {text: (a string), dataPoint: (a Smartgraphs.DataPoint model object)})
  
  startAnnotation(...)
  editAnnotation(...)
  finishAnnotation(...)
  
  
  think about what happens in different states
  
    * data series are collectionViews with 'actsOnSelect' set such that 'pointSelected' action occurs on selection
    * the app state might be set such that the first responder chain responds to 'pointSelected' by adding a label
    * in the GUIDE state, the label (might) inherit some properties from previous responses 
    * in one of the LAB_BOOK states, we'd want to pop up a (modal or non-modal?) pane that lets the learner customize
      the label's property
    * in any state, we want to let the user drag the label around to a different point, or cancel and try again.
    
  Think about how this would happen from a Guide:
    
    A GuideStep might execute a Command 'openLabelTool' or something like that (not 'addLabel', which would imply the 
    label is being added in one fell swoop, from code.)
  
    This makes that LABEL_TOOL state firstResponder. GUIDE_READY remains in the responder chain, but further down.
  
    the LABEL_TOOL state implements the 'pointSelected' action by telling some controller to add a label icon at the
    just-selected point.
  
    the pointSelected action in LABEL_TOOL finishes by calling the 'requestLabelData' action
    
    the GUIDE_READY state implements the 'requestLabelData' action. If the 'setPendingLabelTitle' command has been
    called, previously in this GuidePage, then the pending information is passed via the 'addLabelData' action.
    Otherwise, the handler returns NO (possibly), allowing some default action to take place, like popping up a panel
    requesting more info.
    
    (there might be commands to set the GuidePage state such that it disables the panel that would fill in the label,
     and intead issues some blank or default value that will be updated by a later command, even if no *previous*
     command has yet established the values to be filled in.)

    
  Alternatively, think about how this would happen in Lab Book mode:
  
    The Label Tool button (icon) would have 'openLabelTool' as its action.
    
    This makes LABEL_TOOL firstResponder, via the same code that is called when the Guide issues 'openLabelTool'
    
    Again, the LABEL_TOOL state implements the 'pointSelected' action to add a label.
    
    Again, the 'pointSelected' action in LABEL_TOOL issues the 'requestLabelData' action.
    
    Now, however, the LAB_BOOK state implements 'requestLabelData'. It opens up some kind of label filling-in tool,
    probably by popping up a panel that requests more info. (& probably using a nested store, a la the Sproutcore
    'Signup' demo, to store the data in a cancelable way.) The panel's "OK" button could issue an action which 
    could check the data and commit the records.  
    
  Moreover: the label view's mouseDown & mouseMoved code implement code that visualizes drag and implement the
    'moveLabel' action if dropped (the LABEL_TOOL state would implement this action)

  See how the 'openLabelTool' action and the LABEL_TOOL state don't have to worry about these differing behaviors
  in Guide and Lab Book modes? These behaviors come 'for free' from states farther down the responder chain.
    
  
  So, anyway, what does this mean for context variables in a GuidePage and/or GuideStep?
  
  Thinking about the 'setPendingLabelTitle' action tells us something about this.
  
  First, notice that the label tool should somehow return a reference to the newly created label. (Not via the
  return value of the method that implements pointSelected, of course; this has to return 'YES' or 'NO').
  
  But we probably want to give the new label a name that an author can understand *and* that is guaranteed to be
  unique...
  
  okay probably you just want one code path for modifying a label.. so, not 'setPendingLabelTitle' but
  'setLabelTitle('labelX', newTitle)' *after* label tool is run.
  
  so:
  
    the authoring system might generate a sequence of commands like this:
    
    (newLabelName is a name provided by the author; @learnersTitle is the learners' response taken from this or a 
    previous GuideStep.)
    
      pushLabelToolPopupState
      disableLabelToolPopup
      openLabelTool({labelName: newLabelName})
      setLabelTitle({label: newLabelName, title: @learnersTitle}) 
      popLabelToolPopupState
      
    
   pushLabelToolPopupState would tell GUIDE to push a state variable indicating whether to allow a popup pane
   to show when openLabelTool is called
   
   disableLabelToolPopup disables the popup action (sets a flag that GUIDE uses to know whether to 'override' the
   requestLabelData action by returning YES for the requestLabelData action)
   
   openLabelTool operates as above ... switches to (really, *pushes*) LABEL_TOOL state which implements 'pointSelected'
   NOTE however that it assignes the new label a name (value of newLabelName)
   
   (now, when the label tool issues the 'requestLabelData' action, nothing will happen)
   
   setLabelTitle will modify the new label with the user's preferred title
   
   popLabelToolPopupState restores the previous setting of 'shouldShowLabelToolPopup' (probable name for the flag)
      
   Notice that the 'pushFlag/disableFlag/enableFlag/popFlag' pattern is likely to be reused in several places, so we
   may want to implement a generic mechanism for that sort of thing... but not right away.
   
  
  Okay, so: how to implement references to context variables, again?
  
    1. every responseTemplate should specify names for each field; these get put in the current context
       
       *** (it might actually be useful to scope some things to the current step, page, or guide!)
    
    2. there could be 'set' command to put something to the context
    
    3. Most importantly, you need a way to tell commands to reference not a literal value but a context variable.
       Is that the right way to think about it?
       
    Well, the key point is the Command and CommandInvocation models; they need to 
      (1) tell the Guide to substitute context variables into the argument hash passed via Smartgraphs.sendAction()
      (2) *represent* the variable substitution in a transparent way, for the benefit of authors
    
    
  
  

---

move fixtures-prod to fixtures and add use-fixtures

change guidepagesequence to guide & give Guide model a title

make a mainController that controls app state

put sensor controls, applet controls in a pickerpane

remove cc framework

make a panes/ directory

create 1x1 applet pane with explicit, local jar list. 
Don't mess with visibility but use a *pane* so the applet tag isn't created & appended to doc until needed. Logically a (1x1) applet should be a pane because it doesn't make sense to consider it part of a view hierarchy.

create GuidePane and have it contain dynamic view logic for top, right, or combined view.

make mainPane have a container view with content bound to mainController






command/action model:

  *** this is very murky. Don't architect too much in advance, right?

  things we'd want to record:
  
    create new slide
    add axes to slide
    add data series to graph on slide
    add annotation to slide/series on slide/axes on slide (etc)
    update graph on slide with new, edited version.
    
    
  note we're likely to want to use a "freeze and copy" model to get stuff in the slide.

  also note that these are commands for editing the slide.
  
  How to handle commands for editing stuff "live" that doesn't go to a slide? 
  
  And how do we use the responder chain to handle this?
  
  command history; intersperse "copy to slide" commands in command history.
  

  
  
  
annotation models:
  
  okay, you can have annotations that are added to a slide
  you can have annotations that persist from dialog turn to dialog turn
  you can have annotations that are displayed only during the dialog turn
  you can have annotations that need to be sequenced and can be replayed
  
  what is the essential difference between these?
  
  
  
a "duh" moment: use JSON to persist arguments to verifiers and to to commands.

Alternate duh moment: create models for each type of command
string (or json) config for verifiers & commands is sort of a cheat anyway, right?

Nah, dialogTurns should:

* have a verifier
* have a commandList property which references commands



commands before
commands after


believe it or not, I think a stack model is the best way to do references

  compare ___the series created in this step___ to ___the series created 2 steps ago___. They should __match over 50% of lengthx__   (__xxxxxx__ represents an option in a pulldown or the like)
  
    if they don't:
  
    if they do:

  (green/red highlighting in UI for choosing this.)



  __field 2__ should ___contain the words___ 
  
  ___make a new slide___
  
  copy ___the new table___ to the slide
  
  
okay, given all that, how do we do what we need to do for Thursday?


Remember to make the *model* general. We can use a Guide to let authors write Guides! (guide == wizard)





series and axis controllers:

  dataSeriesController can model a "current data series"

  but note that each series on a graph needs to be displayed!

  graphController might plausibly have an array of series objects
  
  ps. what is transient and what is permanent?
  
  don't model an axis as having a set of features
  


  createAxesCommand(predefine axes or popup a menu to fill out info. Give axes a name)
  
  AddAxes
  
  References (ie, how does a later dialog turn point to the axes it wants to modify) could be an issue.

  You have models for "premade" stuff like premade axes and data series
  
  'verifier' vs. 'inspector'
  

  ... and what you need to be able to say is, 'connect (the student's answer on field 2) to (the title of the annotation)
  
  


7/14/10:

major "modes"

  use the guide
  edit the guide
  edit the lab book
  lab book slideshow


screen configuration in Guide mode

  left pane

  right pane

    split into top & bottom?

    right top
    right bottom


(use sc.formview for answers?)

how to handle enabling input -- either prediction graphs or sensor applet input?






6/16/10:

Refactoring RaphaelViews to work better and to support prediction graphs/higher sampling rates, etc.

Issues:

resizability
dealing with--possibly animating--scale changes
eliding path/point difference (assume points can be their own views, maybe; but lines can't)
avoiding memory leaks or slowness
hooking into SC event system
allowing annotations to be added (and animated) on top. Does SC.Animatable matter here?

do we really need to make scatter plot views extend collection view? Is it worth it?

I think so. Composability: you can implement different types of itemView (one for scatter plots, one for lollipop style plots) Options: you get isSelected support for example as well as recycling of views? Plus you don't have to handle events, I guess.

(How does this play with touch events? I dunno.)

Considerations:




6/10/10:


things to fixup:

  * general scheme of response applet loading .. the data path, at least, shouldn't be in a view; and deal with timing issues!
  * some hooks for/research about applet loading forensics
  * loading indicator for applet controls and delayed or background loading (make sure applet loading doesn't affect page progression)
  * are there issues with pluggin in/unplugging sensor?
  * IE developer tools
  * what about JNA access to host usb libraries?
  * what about static serving of applet jar -- is it possible?
  * update to latest master and confirm it fixes text area click to focus problem.
  * investigate updating to quilmes

  * investigate timing and binding issues within the sproutcore app overall
  * look at the response template model and view ... can using a "student response" model avoid 'manual' clearing and updating?

  * create tests generally
  * create tests that fail in IE?

  * rationalizing how raphael views work 
      (get rid of requirement that raphaelview be direct parent. create a base class that knows when to render? get rid of layer z index hack)

  * decompose the axes model into 2-axes (create yAxisController and xAxisController?)
  * make data series controller and axis controller not singletons, so multiple graphs can be displayed
  * rationalize how plotting works -- axis should handle coordinate transforms!

  * make view for individual static annotations,
  * investigate the 'command' idea; how does this fit in with logbook data model?
  
  * investigate fixes needed for touch to work with raphael views
  * lots more, I'm sure...





----

open question for 6/2: 

how to specify data series and axes per guide page? (actually, that should be easy!)

how to specify applet on/off?


6/1/10:

* let responsetemplates link to a list of ResponseField objects?
* create an 'open response' responsetemplate and let the view use it

* about 'response verifier delegates':

  * in general, the idea of objects that can be configured and that observe the system state are useful.
  * (they convert the system state to a bunch of booleans, basically)
  * some of these will observe the state of the data input from a sensor -- for example is there enough data yet?
  * verifier delegates are *one such kind* that are for the specific case of user-initiated checking
  * dialogturns will eventually have configurable feedback fields that can give 'real time' feedback e.g., 'you haven't entered enough data yet'
  * stateObserverDelegates or whatever we want to rename responseVerifierDelegates could update those fields
  
* so we have the idea that dialogturns can gate progress in a configurable way based on feedback from the state observer
* perhaps a progressGatingController will come into play? that can be configured with a suitable delegate configured via a suitable model object (analogously to responseVerifiers)
* note we sort of have something analogous now in that you can't click check response button until !responseIsIncomplete
* progress is gated now in these ways:
    * you go to the next dialog turn after you click checkResponse (only if response is correct or incorrect, not malformed or incomplete in which case you should get feedback)
    * you can't even click checkresponse until response is 'not incomplete'
* later we can have: 
    * you go to the next turn after you click OK
    * but you can't click OK until state is 'ok to progress'


*** THE CONCEPTS WE'LL USE:

there's a 'progress' button
the button can have a configurable title? ('check response', 'ok'). (As per Kofi let the authoring system enforce name of these things.)
there's a system observer which distill system state into a configurable set of values, and can be configured in extensible way via:
  1. naming the delegate object
  2. config string
  
there's a *separate* response checker that takes the distilled system state and gives yes/no on progress to next step

the system observer object can be used to turn buttons on/off, give 'real time' feedback (ie without waiting for student to click)

the dialog turn has to be configured to 1) use a particular system observer 2) bind certain feedback fields (which *are* predefined) to certain keys on the system observer (which are specified as strings)

I.E. we're blowing up 'response verifier' into two things


*** FOR NOW this doesn't matter.

we just need to implement OK button, right?



*** how would this work?

nextTurnButtonTitle: 'Check My Response'
responseVerifier: response-1    // checks with systemStateDistiller; if null, goto 'nominal response'
systemStateDistiller:'responseTemplate, 'graphSelection'  (-Distiller)

(then there'd be a template language and/or fields on the DialogTurn model that bind the instant-feedback to distiller objects' various properties)

checkResponse -> checkState

responseIsCorrect/responseIsIncorrect -> stateIsOK
responseIsMalformed+responseIsIncomplete+whatever else means that 'stateOK' is not valid -> stateIsValid
checkState was called -> stateWasChecked



*** what do we need now?

nextTurnButtonTitle: "Submit My Answer"
responseVerifier: null means progress button always enabled. *** Actually, we could create a null checker before separating distillers from gatingsupervisors


sigh, all these java-y class names



okay. we're good to go for open response




  


5/30/10:

(renamed CorrectResponse to ResponseVerifer)

OK, now we have a division of responsibility when checking answers.

If the dialog will need to present input area(s) (possibly intermixed with text), the ResponseTemplate will contain the
necessary information (in its templateString)

There should also be an associated ResponseVerifier which has responsibility for checking the answer.

OKAY:

  * responseTemplate should have an array that contains the responses. These might be processed, depending.
  * responseVerifier should have a 'type' parameter that specifies the type of answer to be checked.
   
  based on the responseVerifier's 'type' parameter, the responseVerifier will check a different delegate
  it can pass its 'value' parameter to the delegate, which is responsible for figuring out what to do with it.

  verifier-delegates/
    ReponseTemplateVerifierDelegate
    GraphSelectionVerifierDelegate
 



5/27/10:

view layer changes:

 mainPage.promptView becomes 'dialogView'
 
 



next step: controllers and actions

GuidePageSequenceController

GuidePageController

DialogController

DialogTurnController




5/26/10

What to actually implement to get text dialog working

GuidePageSequence
  pages
  
GuidePage
  activity
  text
  dialog
  
Dialog
  // eventually we'll interpose a dialogstepsequence so that a dialog can have su
  steps
  
DialogStep
  index
  dialog
  beforeText
  responseTemplate: toOne(ResponseTemplate)
  staticAnnotations: (i.e., static, not replayable annotations)
  afterText

ResponseTemplate
  type: 
  formatString:
  correctResponse
  
CorrectResponse
  // a DialogStep without a correctResponse is basically an 'open response'
  responseTemplate: 
  value

StaticAnnotationList:
  annotations: toMany(StaticAnnotation)

StaticAnnotation
  list:       toOne(StaticAnnotation)
  type        (a string)
  args        (?)





5/25/10

new objects:

GuidePageSequence    (an 'activity' or a sequence of 'pages', without all the connotations of 'activity' -- e.g,  it could be a wizard)
ActivityStep          (a 'page' in the 'activity', with the expectation that steps can be followed linearly -- if a student needs help with a step, he gets it in the step itself)
Dialog                (a description of the dialog between system and user that takes place during a single ActivityStep)
DialogStep            (a step in that dialog)

points to remember about Dialogs:

1. the dialog is linear. The expectation is you continue until student 'gets it right'
2. at any point, you might want to, say, have student record their notes about what they're doing. That's a dialogStep?
3. there's an optional 'finish' step after the student gets it right, which must be completed before they can move on.
4. but we'll enforce that there aren't any more 'check responses' at that point.


A dialog step consists of 

text (displayed before or after the answer form)
a graphical action (specified by a 'name'))
an answer form -or- a reflection form (which I guess can take a similar form but doesn't record the answer to the same place and doesn't have a 'check answer' button)
[eventually, you might want to include a button that the user can click on to perform some action like open a tool]
(simplify, simplify! no 'text before' and 'text after' stuff. just text...)


the answer form is a template with (with a list of actions to take after an answer)
the graphical action consists of a list of actions by name
the buttons contain "ok" if no answer form; "show me again" if action; "check my answer" and "i don't know" if there's an answer form
there can also be a list of actions defined in a step

alternatively, a step can be a link to a 'subdialog'

instead of having a 'finally clause', allow a dialog to contain multiple DialogStepSequences.

Answering a question correctly (see AnswerForm) in a DialogStepSequence skips to the next sequence, if any.


I think we have what we need to model this.


GuidePageSequence
  steps: toMany(GuidePage)
  

GuidePage
  guidedUserActivity: toOne(GuidePageSequence)
  text:
  configuration:
  lowerRight: ?
  upperRight: ?
  dialog: toOne(Dialog)


Dialog
  index: Number
  GuidePage: toOne(GuidePage)
  sequences: toMany(DialogStepSequence)
  dialog: toOne(Dialog)
  steps: toMany(DialogSteps)
  

DialogTurnSequence
  dialog: toOne(Dialog)
  index: 
  turns: toMany(DialogTurns)


DialogStep
  index: Number
  sequence: toOne(DialogStepSequence)
  
  beforeText: String
  responseForm: toOne(ResponseForm)
  responseVerifier: toOne(ResponseVerifer)
  graphicalActions: toOne(ActionSequence)

  afterText: String
  subDialog: toOne(Dialog)

  actions: toOne(ActionSequence)
  

ResponseForm:
  type: String  (one of two constants)
  correctResponse:
  eventually, other fields that allow 
    
    
ActionSequence:
  actions: toMany(Action)
  

Action:
  index: Number
  sequence: toOne(ActionSequence)



EARLIER THOUGHTS BELOW:


each DialogStep can 'be' a:

posed question              response buttons: checzk answer, OK (if no answer is expected), I don't know
rephrased question          response buttons: check answer, OK (if no answer is expected), I don't know
subquestion                 response buttons: check answer, OK (if no answer is expected), I don't know
graphical hint              response buttons: check answer, OK (if no answer is expected), show me again
textual hint                response buttons: check answer, OK (if no answer is expected)
reflection opportunity      response buttons: OK
textual response            response buttons: OK (or none if it's the last?)
graphical response          response buttons: OK, show me again

* possibly separate the prompting from the setting of a new response expectation
* the funny bit is the idea of a 'prompt'. we want it to repeat, possibly being overridden. 
**  Actually, we need an 'answer form' independent of the 'prompt'
* each step can have associated with it some actions

trying again...
each step can have

text (the 'prompt' goes here, but this can be a hint or whatever)
an 'answer form' (the idea being these repeat until a new one is introduced)
graphic response
(associated actions)
post-incorrect-response text
post-correct-response text





Dialog:

  firstStep                   (first dialogStep to pose)
  afterCompletionStep:        (follow these steps after success)

DialogStep:

(actions:
  set a new response expectation
  do some named actions that annotate the graph
  do some named actions that display a transient annotation
  set a new reflective response question
  switch to a sub-question...)


  repeatableActions           ('graphical scaffolding')
  
  hasCheckResponseButton
  hasShowAgainButton          (to replay actions ... although, which actions?)
  hasOkButton                 (for 'think about it' or 'write what you think will happen' type dialog steps)

  newResponseExpectation      (set this to a new ResponseExpectation to ask a new question)
  text
  actions                     (a set of actions performed by this step)
  afterCorrectResponseText
  afterIncorrectResponseText
  
  subDialog                   (a dialog branch -- possibly including a new response expectation -- to be followed to completion between this step and the next) 
  nextStep
  

reflectionDialogStep
graphicalDialogStep
textDialogStep
checkAnswerDialogStep


textReponseStep
graphicalResponseStep
learnerInputStep
requestLearnerResponseStep




askForResponse

  OK (if reflective input)
  Watch Again:
  



  
issues:
  checking that there's any response at all
  saving a reflective response
  templating for text output (how to say "put a dropdown here between the words 'ran for' and 'minutes'")
  templating for actions on logbook (e.g., how to say 'student's answer should represent length param of length annotation')
  
  
  
5/17/10


make use of this pattern:



// find contact record.
var contactRecord = MyApp.store.find(MyApp.Contact, 4);
// find events assigned to that contact.
var localEventQuery = SC.Query.local(MyApp.Event, {
   conditions: 'assignedTo = {contact}',
   contact: contactRecord
});

IOW

seq = Smartgraphs.store.find(Smartgraphs.QuestionSequence, 'sequence-1');
query = SC.Query.local(Smartgraphs.Question, { conditions: 'sequence = {sequence}', sequence: seq, orderBy: 'index ASC' })
qs = Smartgraphs.store.find(query)


make questionsequenceview an arraycontroller whose content is that query result
make it single selection, no empty selection

bind questionController to selection

to add:

* segmented view (bind to content)
* next/back buttons (need isFirst, isLast, next(), back() on questionSequenceController)

segmentedview has 'itemvaluekey' and a 'value' properties.


can you bind selection of questionController to that value, or do we have to observe the 'value' and set selection accordingly?




to do:

* adjust the question model with short name
* create a simple activity model (questionSequenceController)
* create a query
* make the questionsequenceview an arraycontroller with the appropriate flags set
* endow questionsequenceview with an 'questionSequence' property that points to a questionsequence model object and sets the content property accordingly
* create segmentedview with appropriate
* create next/back buttons and bind accordinglyx`




5/12/10

let's get back to simple.
keep the tabs the same.
set the first tab view to be a 'new' question view.


question MODEL

  responseType
  prompt
  correctResponse
  correctResponseFeedback
  incorrectResponseFeedback
  
  
question CONTROLLER

  checkAnswer()
  feedback
  shouldAcceptTextResponse
  textResponse
  shouldAcceptGraphicalResponse
  graphicalResponse
  response
  
  
question VIEW

  display prompt
  display response if non-null
  display text area if shouldAcceptTextResponse is YES
  bind 'check answer' button to
  

main.js

  should fetch the first question fixture
  should set up the question controller

main_page.js

  the 'introView' should be a 
  

adjust the fixture 



*** see tomdale on pages and containerviews:

  http://groups.google.com/group/sproutcore/msg/9f59c491b9c27464






you presumably want multiple questionview instances, each bound to a question controller
there should be a higher level object that sets up the question controllers as needed

naah.

* set up your files in your main.js like this:

  (the idea is that this logic could be implemented in an app state/root controller)
  
  create 3 question controllers (which should not have to concern themselves with views!)  
  create 3 off-screen panes bound to those controllers
  each pane contains a questionview
  
  set up a question flow controller
  
   isFirst property (views can observe to disable back button)
   isLast property (views can use to enable forward button)
   items is an array of question controllers
   nowShowing is the current question controller
   endow controller with next(), prev() methods to move nowShowing
   itemEnabledKey - pass through to tab controller
   
   
   eventually the tab controller could 'build' the activity incrementally
   

question controllers:


----

5/5/10:


"allow the user to click a point on the graph to answer the question"

okay, what's the flow we're imagining will eventually happen


a wizard poses a question
  the datapoint relays a selection event to the dataseries it's in
  
  the dataseries relays the event to the slide/slidebuilder
  
  the slidebuilder looks at its policy somehow and knows that the correct event is to delegate to the annotationbuilder
  
  the annotationbuilder sends an addannotation event to the slidebuilder (to notate where the annotation is proposed to happen)
  
  when the 'check answer' button is clicked, the wizard inspects that annotationbuilder's datapoint property
  

decompose this into the models needed for this story:


there should be a controller for a wizard-like component, with a state machine and underlying model...

there should be a



try implementing in this iteration:

a new series data model and corresponding views
a slidebuilder (that accepts setAxes, addSeries and addAnnotation)

a relay between the mousedown on the datapoint model,

 * the datapointview gets a click event
 * its controller notifies the dataseriescontroller
 * the arraycontroller for dataseries sets isselected on the datapoint (triggering re-render)
 
 * however, after this, TURN SELECTION OFF in the dataseriesview control (as we're going to be annotating, not selecting)
 (in general, model the listitemview/listview contract if possible?)
 

 * now, the wizard should be notified directly of the selection event (instead of going through an annotation builder .. yet)

 * wizard should check the value of the selected point and act accordingly
 
 * then, add an annotation to the *slide* object (and redisplay)
 
 
what's needed?

* ignore changes having to do with rewriting wizard


DataPointView
DataPointController
DataSeriesView (at least a new version)
DataSeriesController (at least a new version)
AxisView
AxisController

SlideBuilderView
SlideBuilderController
WizardController


models

Axis
Slide
SimpleAnnotation (no or trivial controller)

Wizard (this could be renamed eventually)


steps?


* refactor DataSeriesView to be a CollectionView with DataSeriesView as the exampleView
* make a 'lab book slide' model & controller
* make a 'simple data point annotation' model
* put the first question in a 'wizard' object
* make it so the wizard causes a 'lab book slide' to be created from the data series
* make the 'lab book slide builder' cause annotations to be displayed
* make it so the wizard checks its answer by getting events relayed from datapoint-dataseries-slide chain, and reflects the answer by simply adding a 'simple annotation' object


---

notes on refactoring dataseriesview

  * rename to dataseriesview from seriesview
  * use the collectionviewdelegate to make decisions regarding selection etc (note the 'annotationbuilder' scenario above implies that selection could be used to indicate which datapoint to annotate, rather than merely to 'select')
  
  * 'collectionview handles event input for the entire collection' (from docs for SC.CollectionView)
  
  * note 'action' and 'actOnSelect' properties of CollectionView
  * note on SC.CollectionView's contentValueKey property: "If you are writing your own custom item view for a collection, you can get this behavior automatically by including the SC.Control mixin on your view. You can also ignore this property if you like. The collection view itself does not use this property to impact rendering."
  * "In general you do not want your child views to actually respond to mouse and keyboard events themselves. It is better to let the collection view do that."
  
  * see the notes on exampleView to implement 
  * nowShowing: "The set of indexes that are currently tracked by the collection view"
  ****  contentIndexForLayerId()!
  * contentIndexesInRect() "Override to return an IndexSet with the indexes that are at least partially visible in the passed rectangle"
  
  * contentPropertyDidChange(): OH! "This is only called if you have set observesContentProperties to YES." (tell Avi`)
  
  * itemViewForContentObject()
  
  
  
  so; the plan?
  
  * how much layout does collectionview really do?
  * and how do we handle context building for raphael?
  
  - moved raphaeljs to frameworks/raphael
  
  what might it look like?
  
  should we make the analogy
  
  layer::svg element
  render : overwrites the layer
  
  contextbuilders keep track of innerhtml
  should contextbuilder overwrite layer?
  
  is there an analogy? 
  
  

okay

- why does overriding createLayer() still result in a div being created? how can this be overridden?
- how does listItemView work?



NOTE

Every dom node created with raphael has a 'raphael' property pointing to the raphael object that represents it
every raphael element has a 'paper' property pointing to the 'main' raphael object
the main raphael object has a 'canvas' (instead of 'node') property pointing to the parent dom element(svg/vml node) containing the paper.

Phew.






 

 


 
 
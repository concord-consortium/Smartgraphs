commands/

states/

inspectors/

---

name things after creating them.

DialogTurn:
  
  beforeText
  commands
  responseTemplate
  afterText
  inspectors
  buttons
  
Button
  enabledWhen (refers to 'context' set up by inspector(s) in DialogTurn)
  title
  commands
  include "go to turn x" based on inspector value


So I am iterating towards Bob's preferred Hypercard-like model after all...

Metadata about questions ('this is multiple choice question 3 and the correct answer is (c)'), etc can be stored on the server! Moreover authors are expected to edit Guides "a level up" from this low level representation used by the runtime. We will probably provide Guides for authors to help them edit Guides for students.

inspectors set up a context in the dialog turn, which can be read by the code executed in buttons.

What happens if you want to *start* a command on turn 1, then *finish* it in turn 2? Presumably they could write to a 'page context', or...


@annotation = StartAnnotation()
@annotation.setTitle(@2)
(...move to new dialog turn)
@annotation.setHeading(@3)
@annotation.finish()
@slide.add(@annotation)

the @annotation lives in the page context ('stack frame'), see?

models to flesh out:

Guide 
GuidePage
DialogTurn
ResponseTemplate
Command
Button



okay...


Guide:
  title       // for display
  name        // for internal reference
  pages
  

GuidePage
  guide
  index
  name        // not modeled as having titles!
  introText
  firstDialogTurn
  
  transient:

  selectedDialogTurn
  isSelectable
  context             // hash of name -> object references


DialogTurn
  name
  
  beforeText
  responseTemplate
  afterText

  commands            // array (ordering counts & I'm too lazy to create a CommandList record type)
  inspectors          // toMany (because why not?)
  buttons

  isLast              // part of the contract with any page that has 'isLast' is that it doesn't access 'context'
  shouldAutoAdvance

  transient:

  context             // hash of name -> object references


Button
  name                // for consistency with command pattern used here
  title               // for consistency with SC.Button; it's the text that goes on the button
  enabledWhen         // json string
  commands


Inspector
  className
  inputNames
  config              // json string  
  outputNames


Command:
  className
  config              // json string
  

ResponseTemplate:

  template        // some template pattern to name the fields and say where they go: "Maria traveled #{dist} #{units}"
  numberOfFields  // what it says
  names           // the field names. Serialized as an array but could be keys to a hash
  types           // radio, select, textarea, textfield, etc.
  itemArrays      // needed for radio/select. Each element is a JSON string representing an array of choice strings.
  prompts         // the ghosted prompt string in textfields/textareas
  
  transient:
  
  values          // the filled-in values


inspector and command classes:

  (note that it's wise to have sensible "combined" behaviors like "create a graph and add it to a frame"
  These commands are likely to be exposed in an "expert view" in the guide editing environment.)
  
  set display to split or combined

  create a new graph G (i.e., give it a name so it can be operated on and referenced later) and show it in pane P

  show pre-existing graph G in a particular pane
  
  merge graph G1 and graph G2 into graph G3 (or G1 or G2)
  
  add series S (from the database) to graph G
  
  add blank series S to graph G and turn on sensor applet controls
  
  add blank series S to graph G and turn on prediction graph controls
  
  add series S to table
  
  change x-axis label ...
  
  disable selection on graph G (or on all graphs...)
  
  enable single selection on series S...
  
  create label (at selected point) with value from response field F (could be any value from the context, ie any 'var')
  
  
  for later:
  
  create slide S
  
  record fields F1, F2, F3 as answer to question Q...
  
  
  
  

create a blank data series S (give it a name)
load presaved series S into graph G   // why not make this a single 
add series S to graph G
add series S to table T

enable sensor input to series S


set the x axis of the graph   (possibly from db)
set the y axis of the graph   (possibly from db)
(set some other property on the graph or its axes)

create a new series
add a series to the graph

setDisplayCommand(...)          // split or combined, for now
addGraphCommand(...)            // for example from graph axes speced in db
addSeriesCommand(...)           // could be empty, or could be 
enableSensorCommand(...)        // sampling interval?
enablePredictionCommand(...)

try that list again.

Remember 
(1) there are 'dialog turn vars' and 'page vars' although we won't call them as such
(2) 

addLabel

  
  

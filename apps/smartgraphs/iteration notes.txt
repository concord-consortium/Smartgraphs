5/26/10

What to actually implement to get text dialog working

GuidedUserActivity
  pages
  
GuidePage
  activity
  text
  dialog
  
Dialog
  // eventually we'll interpose a dialogstepsequence so that a dialog can have su
  steps
  
DialogStep
  index
  dialog
  beforeText
  responseTemplate: toOne(ResponseTemplate)
  staticAnnotations: (i.e., static, not replayable annotations)
  afterText

ResponseTemplate
  type: 
  formatString:
  correctResponse
  
CorrectResponse
  // a DialogStep without a correctResponse is basically an 'open response'
  responseTemplate: 
  value

StaticAnnotationList:
  annotations: toMany(StaticAnnotation)

StaticAnnotation
  list:       toOne(StaticAnnotation)
  type        (a string)
  args        (?)





5/25/10

new objects:

GuidedUserActivity    (an 'activity' or a sequence of 'pages', without all the connotations of 'activity' -- e.g,  it could be a wizard)
ActivityStep          (a 'page' in the 'activity', with the expectation that steps can be followed linearly -- if a student needs help with a step, he gets it in the step itself)
Dialog                (a description of the dialog between system and user that takes place during a single ActivityStep)
DialogStep            (a step in that dialog)

points to remember about Dialogs:

1. the dialog is linear. The expectation is you continue until student 'gets it right'
2. at any point, you might want to, say, have student record their notes about what they're doing. That's a dialogStep?
3. there's an optional 'finish' step after the student gets it right, which must be completed before they can move on.
4. but we'll enforce that there aren't any more 'check responses' at that point.


A dialog step consists of 

text (displayed before or after the answer form)
a graphical action (specified by a 'name'))
an answer form -or- a reflection form (which I guess can take a similar form but doesn't record the answer to the same place and doesn't have a 'check answer' button)
[eventually, you might want to include a button that the user can click on to perform some action like open a tool]
(simplify, simplify! no 'text before' and 'text after' stuff. just text...)


the answer form is a template with (with a list of actions to take after an answer)
the graphical action consists of a list of actions by name
the buttons contain "ok" if no answer form; "show me again" if action; "check my answer" and "i don't know" if there's an answer form
there can also be a list of actions defined in a step

alternatively, a step can be a link to a 'subdialog'

instead of having a 'finally clause', allow a dialog to contain multiple DialogStepSequences.

Answering a question correctly (see AnswerForm) in a DialogStepSequence skips to the next sequence, if any.


I think we have what we need to model this.


GuidedUserActivity
  steps: toMany(GuidePage)
  

GuidePage
  guidedUserActivity: toOne(GuidedUserActivity)
  text:
  configuration:
  lowerRight: ?
  upperRight: ?
  dialog: toOne(Dialog)


Dialog
  index: Number
  GuidePage: toOne(GuidePage)
  sequences: toMany(DialogStepSequence)
  dialog: toOne(Dialog)
  steps: toMany(DialogSteps)
  

DialogStepSequence
  dialog: toOne(Dialog)
  index: 
  steps: toMany(DialogStep)


DialogStep
  index: Number
  sequence: toOne(DialogStepSequence)
  
  beforeText: String
  responseForm: toOne(ResponseForm)
  responseVerifier: toOne(ResponseVerifer)
  graphicalActions: toOne(ActionSequence)

  afterText: String
  subDialog: toOne(Dialog)

  actions: toOne(ActionSequence)
  

ResponseForm:
  type: String  (one of two constants)
  correctResponse:
  eventually, other fields that allow 
    
    
ActionSequence:
  actions: toMany(Action)
  

Action:
  index: Number
  sequence: toOne(ActionSequence)



EARLIER THOUGHTS BELOW:


each DialogStep can 'be' a:

posed question              response buttons: checzk answer, OK (if no answer is expected), I don't know
rephrased question          response buttons: check answer, OK (if no answer is expected), I don't know
subquestion                 response buttons: check answer, OK (if no answer is expected), I don't know
graphical hint              response buttons: check answer, OK (if no answer is expected), show me again
textual hint                response buttons: check answer, OK (if no answer is expected)
reflection opportunity      response buttons: OK
textual response            response buttons: OK (or none if it's the last?)
graphical response          response buttons: OK, show me again

* possibly separate the prompting from the setting of a new response expectation
* the funny bit is the idea of a 'prompt'. we want it to repeat, possibly being overridden. 
**  Actually, we need an 'answer form' independent of the 'prompt'
* each step can have associated with it some actions

trying again...
each step can have

text (the 'prompt' goes here, but this can be a hint or whatever)
an 'answer form' (the idea being these repeat until a new one is introduced)
graphic response
(associated actions)
post-incorrect-response text
post-correct-response text





Dialog:

  firstStep                   (first dialogStep to pose)
  afterCompletionStep:        (follow these steps after success)

DialogStep:

(actions:
  set a new response expectation
  do some named actions that annotate the graph
  do some named actions that display a transient annotation
  set a new reflective response question
  switch to a sub-question...)


  repeatableActions           ('graphical scaffolding')
  
  hasCheckResponseButton
  hasShowAgainButton          (to replay actions ... although, which actions?)
  hasOkButton                 (for 'think about it' or 'write what you think will happen' type dialog steps)

  newResponseExpectation      (set this to a new ResponseExpectation to ask a new question)
  text
  actions                     (a set of actions performed by this step)
  afterCorrectResponseText
  afterIncorrectResponseText
  
  subDialog                   (a dialog branch -- possibly including a new response expectation -- to be followed to completion between this step and the next) 
  nextStep
  

reflectionDialogStep
graphicalDialogStep
textDialogStep
checkAnswerDialogStep


textReponseStep
graphicalResponseStep
learnerInputStep
requestLearnerResponseStep




askForResponse

  OK (if reflective input)
  Watch Again:
  



  
issues:
  checking that there's any response at all
  saving a reflective response
  templating for text output (how to say "put a dropdown here between the words 'ran for' and 'minutes'")
  templating for actions on logbook (e.g., how to say 'student's answer should represent length param of length annotation')
  
  
  
5/17/10


make use of this pattern:



// find contact record.
var contactRecord = MyApp.store.find(MyApp.Contact, 4);
// find events assigned to that contact.
var localEventQuery = SC.Query.local(MyApp.Event, {
   conditions: 'assignedTo = {contact}',
   contact: contactRecord
});

IOW

seq = Smartgraphs.store.find(Smartgraphs.QuestionSequence, 'sequence-1');
query = SC.Query.local(Smartgraphs.Question, { conditions: 'sequence = {sequence}', sequence: seq, orderBy: 'index ASC' })
qs = Smartgraphs.store.find(query)


make questionsequenceview an arraycontroller whose content is that query result
make it single selection, no empty selection

bind questionController to selection

to add:

* segmented view (bind to content)
* next/back buttons (need isFirst, isLast, next(), back() on questionSequenceController)

segmentedview has 'itemvaluekey' and a 'value' properties.


can you bind selection of questionController to that value, or do we have to observe the 'value' and set selection accordingly?




to do:

* adjust the question model with short name
* create a simple activity model (questionSequenceController)
* create a query
* make the questionsequenceview an arraycontroller with the appropriate flags set
* endow questionsequenceview with an 'questionSequence' property that points to a questionsequence model object and sets the content property accordingly
* create segmentedview with appropriate
* create next/back buttons and bind accordinglyx`




5/12/10

let's get back to simple.
keep the tabs the same.
set the first tab view to be a 'new' question view.


question MODEL

  responseType
  prompt
  correctResponse
  correctResponseFeedback
  incorrectResponseFeedback
  
  
question CONTROLLER

  checkAnswer()
  feedback
  shouldAcceptTextResponse
  textResponse
  shouldAcceptGraphicalResponse
  graphicalResponse
  response
  
  
question VIEW

  display prompt
  display response if non-null
  display text area if shouldAcceptTextResponse is YES
  bind 'check answer' button to
  

main.js

  should fetch the first question fixture
  should set up the question controller

main_page.js

  the 'introView' should be a 
  

adjust the fixture 



*** see tomdale on pages and containerviews:

  http://groups.google.com/group/sproutcore/msg/9f59c491b9c27464






you presumably want multiple questionview instances, each bound to a question controller
there should be a higher level object that sets up the question controllers as needed

naah.

* set up your files in your main.js like this:

  (the idea is that this logic could be implemented in an app state/root controller)
  
  create 3 question controllers (which should not have to concern themselves with views!)  
  create 3 off-screen panes bound to those controllers
  each pane contains a questionview
  
  set up a question flow controller
  
   isFirst property (views can observe to disable back button)
   isLast property (views can use to enable forward button)
   items is an array of question controllers
   nowShowing is the current question controller
   endow controller with next(), prev() methods to move nowShowing
   itemEnabledKey - pass through to tab controller
   
   
   eventually the tab controller could 'build' the activity incrementally
   

question controllers:


----

5/5/10:


"allow the user to click a point on the graph to answer the question"

okay, what's the flow we're imagining will eventually happen


a wizard poses a question
  the datapoint relays a selection event to the dataseries it's in
  
  the dataseries relays the event to the slide/slidebuilder
  
  the slidebuilder looks at its policy somehow and knows that the correct event is to delegate to the annotationbuilder
  
  the annotationbuilder sends an addannotation event to the slidebuilder (to notate where the annotation is proposed to happen)
  
  when the 'check answer' button is clicked, the wizard inspects that annotationbuilder's datapoint property
  

decompose this into the models needed for this story:


there should be a controller for a wizard-like component, with a state machine and underlying model...

there should be a



try implementing in this iteration:

a new series data model and corresponding views
a slidebuilder (that accepts setAxes, addSeries and addAnnotation)

a relay between the mousedown on the datapoint model,

 * the datapointview gets a click event
 * its controller notifies the dataseriescontroller
 * the arraycontroller for dataseries sets isselected on the datapoint (triggering re-render)
 
 * however, after this, TURN SELECTION OFF in the dataseriesview control (as we're going to be annotating, not selecting)
 (in general, model the listitemview/listview contract if possible?)
 

 * now, the wizard should be notified directly of the selection event (instead of going through an annotation builder .. yet)

 * wizard should check the value of the selected point and act accordingly
 
 * then, add an annotation to the *slide* object (and redisplay)
 
 
what's needed?

* ignore changes having to do with rewriting wizard


DataPointView
DataPointController
DataSeriesView (at least a new version)
DataSeriesController (at least a new version)
AxisView
AxisController

SlideBuilderView
SlideBuilderController
WizardController


models

Axis
Slide
SimpleAnnotation (no or trivial controller)

Wizard (this could be renamed eventually)


steps?


* refactor DataSeriesView to be a CollectionView with DataSeriesView as the exampleView
* make a 'lab book slide' model & controller
* make a 'simple data point annotation' model
* put the first question in a 'wizard' object
* make it so the wizard causes a 'lab book slide' to be created from the data series
* make the 'lab book slide builder' cause annotations to be displayed
* make it so the wizard checks its answer by getting events relayed from datapoint-dataseries-slide chain, and reflects the answer by simply adding a 'simple annotation' object


---

notes on refactoring dataseriesview

  * rename to dataseriesview from seriesview
  * use the collectionviewdelegate to make decisions regarding selection etc (note the 'annotationbuilder' scenario above implies that selection could be used to indicate which datapoint to annotate, rather than merely to 'select')
  
  * 'collectionview handles event input for the entire collection' (from docs for SC.CollectionView)
  
  * note 'action' and 'actOnSelect' properties of CollectionView
  * note on SC.CollectionView's contentValueKey property: "If you are writing your own custom item view for a collection, you can get this behavior automatically by including the SC.Control mixin on your view. You can also ignore this property if you like. The collection view itself does not use this property to impact rendering."
  * "In general you do not want your child views to actually respond to mouse and keyboard events themselves. It is better to let the collection view do that."
  
  * see the notes on exampleView to implement 
  * nowShowing: "The set of indexes that are currently tracked by the collection view"
  ****  contentIndexForLayerId()!
  * contentIndexesInRect() "Override to return an IndexSet with the indexes that are at least partially visible in the passed rectangle"
  
  * contentPropertyDidChange(): OH! "This is only called if you have set observesContentProperties to YES." (tell Avi`)
  
  * itemViewForContentObject()
  
  
  
  so; the plan?
  
  * how much layout does collectionview really do?
  * and how do we handle context building for raphael?
  
  - moved raphaeljs to frameworks/raphael
  
  what might it look like?
  
  should we make the analogy
  
  layer::svg element
  render : overwrites the layer
  
  contextbuilders keep track of innerhtml
  should contextbuilder overwrite layer?
  
  is there an analogy? 
  
  

okay

- why does overriding createLayer() still result in a div being created? how can this be overridden?
- how does listItemView work?



NOTE

Every dom node created with raphael has a 'raphael' property pointing to the raphael object that represents it
every raphael element has a 'paper' property pointing to the 'main' raphael object
the main raphael object has a 'canvas' (instead of 'node') property pointing to the parent dom element(svg/vml node) containing the paper.

Phew.






 

 


 
 